`timescale 1ns / 1ps

module jk_ff(
    input J,
    input K,
    input clk,
    input reset,
    output reg Q
);
always @(posedge clk or posedge reset) begin
    if (reset)
        Q <= 1'b0;
    else begin
        case ({J,K})
            2'b00: Q <= Q;
            2'b01: Q <= 1'b0;
            2'b10: Q <= 1'b1;
            2'b11: Q <= ~Q;
        endcase
    end
end
endmodule

module jk_ff_tb;
reg J, K, clk, reset;
wire Q;

jk_ff dut(.J(J), .K(K), .clk(clk), .reset(reset), .Q(Q));

initial begin
    clk = 0;
    forever #5 clk = ~clk;
end

initial begin
    reset = 1; J = 0; K = 0;
    #10 reset = 0;

    J = 0; K = 0; #10;
    J = 0; K = 1; #10;
    J = 1; K = 0; #10;
    J = 1; K = 1; #10;
    J = 1; K = 1; #10;
    $stop;
end
endmodule
`timescale 1ns / 1ps

module jk_ff(
    input J,
    input K,
    input clk,
    input reset,
    output reg Q
);
always @(posedge clk or posedge reset) begin
    if (reset)
        Q <= 1'b0;
    else begin
        case ({J,K})
            2'b00: Q <= Q;
            2'b01: Q <= 1'b0;
            2'b10: Q <= 1'b1;
            2'b11: Q <= ~Q;
        endcase
    end
end
endmodule

module jk_ff_tb;
reg J, K, clk, reset;
wire Q;

jk_ff dut(.J(J), .K(K), .clk(clk), .reset(reset), .Q(Q));

initial begin
    clk = 0;
    forever #5 clk = ~clk;
end

initial begin
    reset = 1; J = 0; K = 0;
    #10 reset = 0;

    J = 0; K = 0; #10;
    J = 0; K = 1; #10;
    J = 1; K = 0; #10;
    J = 1; K = 1; #10;
    J = 1; K = 1; #10;
    $stop;
end
endmodule
